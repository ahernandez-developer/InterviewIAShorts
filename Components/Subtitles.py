# Components/Subtitles.py
from __future__ import annotations
import math
from pathlib import Path
import shutil
import subprocess
from typing import List, Dict, Any

def seconds_to_ass_time(seconds: float) -> str:
    """Converts seconds to ASS time format (H:MM:SS.ss)."""
    if seconds is None or not math.isfinite(seconds):
        seconds = 0.0
    m, s = divmod(seconds, 60)
    h, m = divmod(m, 60)
    return f"{int(h)}:{int(m):02d}:{int(s):02d}.{int((s - int(s)) * 100):02d}"

ASS_HEADER_TEMPLATE = """
[Script Info]
; Script generated by AI Shorts Generator
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
PlayResX: 1080
PlayResY: 1920
YCbCr Matrix: TV.709

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,{font_name},{font_size},&H00{primary_color},&H000000FF,&H00{outline_color},&H80000000,-1,0,0,0,100,100,0,0,1,{outline_width},2,2,10,10,{margin_v},1
"""

def generate_ass(
    transcriptions: List[Dict[str, Any]],
    ass_path: str | Path,
    font_name: str = "Impact",
    font_size: int = 65,
    primary_color: str = "FFFFFF", # White
    outline_color: str = "000000", # Black
    outline_width: int = 2,
    margin_v: int = 200, # Vertical margin from bottom
    max_gap_seconds: float = 0.35,
    max_words_per_line: int = 8, # Safety break for long lines
) -> None:
    """
    Generates a .ass file with dynamic subtitles grouped by speech pauses.
    """
    ass_path = Path(ass_path)
    ass_path.parent.mkdir(parents=True, exist_ok=True)

    header = ASS_HEADER_TEMPLATE.format(
        font_name=font_name,
        font_size=font_size,
        primary_color=primary_color,
        outline_color=outline_color,
        outline_width=outline_width,
        margin_v=margin_v
    )

    with open(ass_path, "w", encoding="utf-8") as f:
        f.write(header.strip() + "\n\n[Events]\n")
        f.write("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n")

        for segment in transcriptions:
            words = segment.get("words", [])
            if not words:
                continue
            
            word_buffer = []
            # Use the segment start time as the initial end time for gap calculation
            last_word_end = segment.get('start', 0)

            def write_buffer(buf):
                if not buf:
                    return
                start_time = seconds_to_ass_time(buf[0]['start'])
                end_time = seconds_to_ass_time(buf[-1]['end'])
                text = " ".join(w['word'].strip() for w in buf)
                dialogue_line = f"Dialogue: 0,{start_time},{end_time},Default,,0,0,0,,{text}"
                f.write(dialogue_line + "\n")

            for word_info in words:
                # Skip words that are just punctuation or have no text
                if not word_info.get('word') or not word_info.get('word').strip():
                    continue

                gap = word_info['start'] - last_word_end
                
                # Flush buffer if there's a significant pause or the line is getting too long
                if word_buffer and (gap > max_gap_seconds or len(word_buffer) >= max_words_per_line):
                    write_buffer(word_buffer)
                    word_buffer = []

                word_buffer.append(word_info)
                last_word_end = word_info['end']

            # Write any remaining words in the buffer after the loop
            if word_buffer:
                write_buffer(word_buffer)

    print(f"‚úÖ Dynamic ASS subtitles (by pause) generated at: {ass_path}")

def burn_in_subtitles(
    video_path: str | Path,
    subtitle_path: str | Path,
    output_path: str | Path,
) -> None:
    """
    Burns in subtitles from an ASS file into a video using ffmpeg.
    """
    video_path = Path(video_path)
    subtitle_path = Path(subtitle_path)
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    escaped_subtitle_path = str(subtitle_path.resolve()).replace("\\", "/").replace(":", "\\:")

    ffmpeg_cmd = [
        "ffmpeg",
        "-y",
        "-i", str(video_path),
        "-vf", f"subtitles='{escaped_subtitle_path}'",
        "-c:a", "copy",
        "-c:v", "h264_nvenc",
        "-preset", "p5",
        "-b:v", "8M",
        "-maxrate", "8M",
        "-bufsize", "16M",
        str(output_path)
    ]

    print(f"üî• Burning in subtitles...")
    try:
        result = subprocess.run(ffmpeg_cmd, check=True, capture_output=True, text=True, encoding='utf-8')
        print(f"‚úÖ Video with subtitles saved at: {output_path}")
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Error burning in subtitles with ffmpeg.")
        print(f"   Command: {' '.join(e.cmd)}")
        print(f"   Stderr: {e.stderr}")
        raise
